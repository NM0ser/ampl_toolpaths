
// Moved the #include <OpenGl_GraphicsDriver.hxx> 
// and added 9 #undef lines to get to build in Linux
#include <OpenGl_GraphicDriver.hxx>
#undef Bool
#undef CursorShape
#undef None
#undef KeyPress
#undef KeyRelease
#undef FocusIn
#undef FocusOut
#undef FontChange
#undef Expose

#include "occView.h"

#include <QMenu>
#include <QMouseEvent>
#include <QRubberBand>
#include <QStyleFactory>

// occ header files.
#include <V3d_View.hxx>

#include <Aspect_Handle.hxx>
#include <Aspect_DisplayConnection.hxx>

#ifdef WNT
#include <WNT_Window.hxx>
#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
#include <Cocoa_Window.hxx>
#else
#include <Xw_Window.hxx>
#endif

// the key for multi selection :
#define MULTISELECTIONKEY Qt::ShiftModifier

// the key for shortcut ( use to activate dynamic rotation, panning )
#define CASCADESHORTCUTKEY Qt::ControlModifier

static Handle(Graphic3d_GraphicDriver)& GetGraphicDriver()
{
	static Handle(Graphic3d_GraphicDriver) aGraphicDriver;
	return aGraphicDriver;
}

OccView::OccView(QWidget* parent)
	: QOpenGLWidget(parent),
	myXmin(0),
	myYmin(0),
	myXmax(0),
	myYmax(0),
	myCurrentMode(CurAction3d_DynamicRotation),
	myDegenerateModeIsOn(Standard_True),
	myRectBand(NULL)
{
	// No Background
	setBackgroundRole(QPalette::NoRole);

	// Enable the mouse tracking, by default the mouse tracking is disabled.
	setMouseTracking(true);

}

void OccView::init()
{
	// Create Aspect_DisplayConnection
	Handle(Aspect_DisplayConnection) aDisplayConnection =
		new Aspect_DisplayConnection();

	// Get graphic driver if it exists, otherwise initialise it
	if (GetGraphicDriver().IsNull())
	{
		GetGraphicDriver() = new OpenGl_GraphicDriver(aDisplayConnection);
	}

	// Get window handle. This returns something suitable for all platforms.
	WId window_handle = (WId)winId();

	// Create appropriate window for platform
#ifdef WNT
	Handle(WNT_Window) wind = new WNT_Window((Aspect_Handle)window_handle);
#elif defined(__APPLE__) && !defined(MACOSX_USE_GLX)
	Handle(Cocoa_Window) wind = new Cocoa_Window((NSView *)window_handle);
//#else
//	Handle(Xw_Window) wind = new Xw_Window(aDisplayConnection, (Window)window_handle);
#endif

	// Create V3dViewer and V3d_View
	myViewer = new V3d_Viewer(GetGraphicDriver(), (short* const)"viewer");

	myView = myViewer->CreateView();

	myView->SetWindow(wind);
	if (!wind->IsMapped()) wind->Map();

	// Create AISInteractiveContext
	myContext = new AIS_InteractiveContext(myViewer);

	// Set up lights etc
	myViewer->SetDefaultLights();
	myViewer->SetLightOn();

	myView->SetBackgroundColor(Quantity_NOC_BLACK);
	myView->MustBeResized();
	myView->TriedronDisplay(Aspect_TOTP_LEFT_LOWER, Quantity_NOC_GOLD, 0.08, V3d_ZBUFFER);

	myContext->SetDisplayMode(AIS_Shaded);
}

const Handle(AIS_InteractiveContext)& OccView::getContext() const
{
	return myContext;
}

void OccView::paintEvent(QPaintEvent* e)
{
	// eliminate the warning C4100: 'e' : unreferenced formal parameter
	Q_UNUSED(e);

	if (myContext.IsNull())
	{
		init();
	}

	myView->Redraw();
}

void OccView::resizeEvent(QResizeEvent* e)
{
	Q_UNUSED(e);

	if (!myView.IsNull())
	{
		myView->MustBeResized();
	}
}

void OccView::fitAll(void)
{
	myView->FitAll();
	myView->ZFitAll();
	myView->Redraw();
}

void OccView::reset(void)
{
	myView->Reset();
}

void OccView::pan(void)
{
	myCurrentMode = CurAction3d_DynamicPanning;
}

void OccView::zoom(void)
{
	myCurrentMode = CurAction3d_DynamicZooming;
}

void OccView::rotate(void)
{
	myCurrentMode = CurAction3d_DynamicRotation;
}


void OccView::mousePressEvent(QMouseEvent* e)
{
	if (e->button() == Qt::LeftButton)
	{
		onLButtonDown((e->buttons() | e->modifiers()), e->pos());
	}
	else if (e->button() == Qt::MidButton)
	{
		onMButtonDown((e->buttons() | e->modifiers()), e->pos());
	}
	else if (e->button() == Qt::RightButton)
	{
		onRButtonDown((e->buttons() | e->modifiers()), e->pos());
	}
}

void OccView::mouseReleaseEvent(QMouseEvent* e)
{
	if (e->button() == Qt::LeftButton)
	{
		onLButtonUp(e->buttons() | e->modifiers(), e->pos());
	}
	else if (e->button() == Qt::MidButton)
	{
		onMButtonUp(e->buttons() | e->modifiers(), e->pos());
	}
	else if (e->button() == Qt::RightButton)
	{
		onRButtonUp(e->buttons() | e->modifiers(), e->pos());
	}
}

void OccView::mouseMoveEvent(QMouseEvent * e)
{
	onMouseMove(e->buttons(), e->pos());
}

void OccView::wheelEvent(QWheelEvent * e)
{
	onMouseWheel(e->buttons(), e->delta(), e->pos());
}

void OccView::onLButtonDown(const int theFlags, const QPoint thePoint)
{
	Q_UNUSED(theFlags);

	// Save the current mouse coordinate in min.
	myXmin = thePoint.x();
	myYmin = thePoint.y();
	myXmax = thePoint.x();
	myYmax = thePoint.y();

}

void OccView::onMButtonDown(const int theFlags, const QPoint thePoint)
{
	Q_UNUSED(theFlags);

	// Save the current mouse coordinate in min.
	myXmin = thePoint.x();
	myYmin = thePoint.y();
	myXmax = thePoint.x();
	myYmax = thePoint.y();

	if (myCurrentMode == CurAction3d_DynamicRotation)
	{
		myView->StartRotation(thePoint.x(), thePoint.y());
	}
}

void OccView::onRButtonDown(const int theFlags, const QPoint thePoint)
{
	Q_UNUSED(theFlags);
	Q_UNUSED(thePoint);
}

void OccView::onMouseWheel(const int theFlags, const int theDelta, const QPoint thePoint)
{
	Q_UNUSED(theFlags);

	Standard_Integer aFactor = 16;

	Standard_Integer aX = thePoint.x();
	Standard_Integer aY = thePoint.y();

	if (theDelta > 0)
	{
		aX += aFactor;
		aY += aFactor;
	}
	else
	{
		aX -= aFactor;
		aY -= aFactor;
	}

	myView->Zoom(thePoint.x(), thePoint.y(), aX, aY);
}

void OccView::addItemInPopup(QMenu* theMenu)
{
	Q_UNUSED(theMenu);
}

void OccView::popup(const int x, const int y)
{
	Q_UNUSED(x);
	Q_UNUSED(y);
}

void OccView::onLButtonUp(const int theFlags, const QPoint thePoint)
{
	// Hide the QRubberBand
	if (myRectBand)
	{
		myRectBand->hide();
	}

	// Ctrl for multi selection.
	if (thePoint.x() == myXmin && thePoint.y() == myYmin)
	{
		if (theFlags & Qt::ControlModifier)
		{
			multiInputEvent(thePoint.x(), thePoint.y());
		}
		else
		{
			inputEvent(thePoint.x(), thePoint.y());
		}
	}

}

void OccView::onMButtonUp(const int theFlags, const QPoint thePoint)
{
	Q_UNUSED(theFlags);

	if (thePoint.x() == myXmin && thePoint.y() == myYmin)
	{
		panByMiddleButton(thePoint);
	}
}

void OccView::onRButtonUp(const int theFlags, const QPoint thePoint)
{
	Q_UNUSED(theFlags);

	popup(thePoint.x(), thePoint.y());
}

void OccView::onMouseMove(const int theFlags, const QPoint thePoint)
{
	// Draw the rubber band.
	if (theFlags & Qt::LeftButton)
	{
		drawRubberBand(myXmin, myYmin, thePoint.x(), thePoint.y());

		dragEvent(thePoint.x(), thePoint.y());
	}

	// Ctrl for multi selection.
	if (theFlags & Qt::ControlModifier)
	{
		multiMoveEvent(thePoint.x(), thePoint.y());
	}
	else
	{
		moveEvent(thePoint.x(), thePoint.y());
	}

	// Middle button.
	if (theFlags & Qt::MidButton)
	{
		switch (myCurrentMode)
		{
		case CurAction3d_DynamicRotation:
			myView->Rotation(thePoint.x(), thePoint.y());
			break;

		case CurAction3d_DynamicZooming:
			myView->Zoom(myXmin, myYmin, thePoint.x(), thePoint.y());
			break;

		case CurAction3d_DynamicPanning:
			myView->Pan(thePoint.x() - myXmax, myYmax - thePoint.y());
			myXmax = thePoint.x();
			myYmax = thePoint.y();
			break;

		default:
			break;
		}
	}

}

void OccView::dragEvent(const int x, const int y)
{
	myContext->Select(myXmin, myYmin, x, y, myView);

	emit selectionChanged();
}

void OccView::multiDragEvent(const int x, const int y)
{
	myContext->ShiftSelect(myXmin, myYmin, x, y, myView);

	emit selectionChanged();

}

void OccView::inputEvent(const int x, const int y)
{
	Q_UNUSED(x);
	Q_UNUSED(y);

	myContext->Select();

	emit selectionChanged();
}

void OccView::multiInputEvent(const int x, const int y)
{
	Q_UNUSED(x);
	Q_UNUSED(y);

	myContext->ShiftSelect();

	emit selectionChanged();
}

void OccView::moveEvent(const int x, const int y)
{
	myContext->MoveTo(x, y, myView);
}

void OccView::multiMoveEvent(const int x, const int y)
{
	myContext->MoveTo(x, y, myView);
}

void OccView::drawRubberBand(const int minX, const int minY, const int maxX, const int maxY)
{
	QRect aRect;

	// Set the rectangle correctly.
	(minX < maxX) ? (aRect.setX(minX)) : (aRect.setX(maxX));
	(minY < maxY) ? (aRect.setY(minY)) : (aRect.setY(maxY));

	aRect.setWidth(abs(maxX - minX));
	aRect.setHeight(abs(maxY - minY));

	if (!myRectBand)
	{
		myRectBand = new QRubberBand(QRubberBand::Rectangle, this);

		// setStyle is important, set to windows style will just draw
		// rectangle frame, otherwise will draw a solid rectangle.
		myRectBand->setStyle(QStyleFactory::create("windows"));
	}

	myRectBand->setGeometry(aRect);
	myRectBand->show();
}

void OccView::panByMiddleButton(const QPoint& thePoint)
{
	Standard_Integer aCenterX = 0;
	Standard_Integer aCenterY = 0;

	QSize aSize = size();

	aCenterX = aSize.width() / 2;
	aCenterY = aSize.height() / 2;

	myView->Pan(aCenterX - thePoint.x(), thePoint.y() - aCenterY);
}
